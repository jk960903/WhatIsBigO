
# 3. Database
**:book: Contents**
- [3. Database](#3-database)
    * [SQL과 RDBMS](#sql과-rdbms)
    * [SQL과 NoSQL 차이](#sql과-nosql-차이)
    * [트랜잭션이란](#트랜잭션이란)
    * [트랜잭션 격리 수준](#트랜잭션-격리-수준)
    * [Index란](#index란)
    * [InMemory DB가 필요한 이유](#inmemory-db가-필요한-이유)
    * [ORM 이란](#orm이란)
    * [JOIN](#join)

---

### SQL과 RDBMS


- RDBMS
   - 관계형 데이터 베이스 관리 시스템으로 관계형 모델을 기반으로 하는 DBMS 유형이다.
- SQL
  - Structured Query Language로 RDBMS에서 자료를 관리 및 처리하기 위해 설계된 언어


### SQL과 NoSQL 차이
 **NoSQL**
  - RDB형태의 관계형 데이터베이스가 아닌 다른 형태의 데이터 저장 기술을 의미 RDBMS처럼 테이블간의 관계를 정의하지 않는다.
  - 일반적으로 테이블간 Join도 불가능함 
  - RDBMS 스키마에 맞추어 데이터를 관리해야하는 한계를 극복하고 수평적 확장성 (Scale - Out)을 쉽게 할수 있다는 장점이 있음
  
  * Key - Value 데이터 베이스
    Key 와 Value 쌍으로 저장되는 데이터 베이스  Key는 Value에 접근하기 위한 용도로 사용되고 값은 어떠한 형태의 데이터라도 담을 수 있다. 이미지 비디오 등도 가능
    대표적인 Key - Value Model로는 Redis , Amazon Dynamo DB가 있다.
    
  * Document DataBase
    Key와 Document 형태로 저장된다. Key - Value 모델과 다른점은 Value가 계증적인 형태인 도큐먼트로 저장된다. 객체지향에서의 객체와 유사하며 하나의 단위로 저장된다.
    하나의 객체를 여러 개의 테이블에 나눠 저장할 필요가 없어진다는 뜻 즉 RDBMS처럼 객체 - 관계가 필요하지 않다. 객체 자체를 Document형태로 바로 저장하기 때문이다.
    단점은 사용이 번거롭고 쿼리가 SQL과 다르다는 점 Document Model에서는 Json이나 XML 형태로 출력되기 때문에 사용 방법이 RDBMS에서의 질의 결과를 사용하는 방법과 다름
  
  * Wide Column Database
    키에서 필드를 결정하는 방법 키는 Row와 Column-family , Column-name을 가지는데 연관된 데이터들은 같은 Column-family 안에 속해 있으며 각자의 Column - name을 가짐 
    이렇게 저장된 데이터는 하나의 커다란 테이블로 표현이 가능 하며 질의는 ROW , Column-family , Column-name을 통해 수행
    HBase와 Hypertable
    (이부분은 처음 찾아보는 부분이라 좀더 상세하게 찾아보고 공부할 필요가 있음)
    
  * Graph Database
    데이터를 Node와 Edge, property와 함께 그래프 구조를 사용하여 데이터를 표현하고 저장하는 DB 개체와 관계를 그래프 형태로 표현한것이므로 관계형 모델이라고도 할수 있음
    데이터 간의 관계가 탐색의 키일 경우 매우 적합하다. 페이스북 이나 트위터 같은 SNS등에 적합하고 연관된 데이터를 추천해주는 추천 엔진 , 패턴인식등에 많이 사용된다.
    대표적인 것으로 Neo4J가 있다.
    
 **RDBMS와 NoSQL의 장단점**
  * RDBMS
    - 장점
      - 정해진 스키마에 따라 데이터를 저장하여야 하므로 명확한 데이터 구조를 보장하고 있다. 
      - 관계는 각 데이터를 중복없이 한번만 저장 가능
    - 단점
      - 테이블간 관계를 맺고 있기 때문에 시스템이 커질경우 join문이 많은 복잡한 쿼리문이 만들어질 가능성이 있다..
      - 성능 향상을 위해서 서버의 성능을 향상시켜야하는 Scale-up만을 지원 이로인해 비용이 기하급수적으로 증가할 수 있다.
      - 스키마로 인해 데이터가 유연하지 못하고 변경할 경우 매우 번거롭고 어렵다.
  * NoSQL
    - 장점
      - 스키마가 없어 유연하며 자유로운 데이터 구조를 만드는 것이 가능하다. 언제든 저장된 데이터를 조정하고 새로운 필드를 추가할 수 있다.
      - 데이터 분산이 용이하고 성능 향상을 위해 Scale-Up 뿐만이 아니라 Scale-Out도 가능 하다.
    - 단점
      - 데이터 중복이 발생할 수 있어 데이터가 변경될 경우 모든 컬렉션에서 수행해야 한다.
      - 스키마가 존재하지 않아 명확한 데이터 구조를 보장하지 않으며 데이터 구조 결정에 어려움을 겪을 수 있다.

 **RDBMS NoSQL 각각 어디테 사용하는것이 좋을까**
  * RDBMS
    - 데이터 구조가 명확하고 변경될 여지가 적고 명확한 스키마가 중요한경우 , 중복된 데이터가 없어 변경이 용이하기 때문에 데이터가 자주 변경이 이루어지는 시스템
  
  * NoSQL
    - 정확한 데이터 구조를 알수 없는 경우에 사용 Update가 자주 이루어지지 않는 시스템에 막대한 데이터를 저장해야해서 분산처리를 해야하는 시스템
    - 
### 트랜잭션이란
 * 트랜잭션이란?
  - 데이터 베이스의 상태를 변환시키는 하나의 논리적인 작업 단위를 구성하는 연산들의 집합
    Ex) A 계좌를 통한 결제가 이루어진다
      a. 사용자가 입력한 계좌가 존재하고 적상적인지 확인한다.
      b. A계좌에서 결제할 금액을 확인한다.
      c. A계좌에서 결제할 금액만큼 차감한다.
      d. A계좌에 결제 내역을 추가한다. 
 
 * 트랜잭션 특징
  - 하나의 트랜잭션은 Commit 되거나 RollBack 된다.
    A. Commit
      - 트랜잭션에 대한 작업이 성공적으로 끝나 데이터베이스가 다시 일관된 상태를 유지하기위해 사용하는 연산 
    B. RollBack
      - 하나의 트랜잭션 처리가 비정상적으로 종료되어 데이터베이스의 일관성을 깨뜨렸을 때 사용하는 연산 , 일부가 정상적으로 처리되었다하더라도 원자성을 구현하기위해 모든 연살을 취호 하는 연산
      - RollBack 시에는 해당 트랜잭션을 폐기한다.
  - 트랜잭션의 성질 (ACID)
    * 원자성 (Atomicity)
       트랜잭션의 모든 연산은 정상적으로 수행 완료되거나 아니면 전혀 어떠한 연산도 수행되지 않은 상태로 되돌려야한다.
    * 일관성(Consistency)
       트랜잭션 완료 후에도 데이터 베이스가 일관된 상태를 유지해야한다.
    * 독립성(Isolation)
      하나의 트랜잭션이 실행하는 도중에 변경된 데이터는 이 트랜잭션이 완료될 때 까지 다른 트랜잭션이 참조하지 못한다.
    * 지속성(Durability)
      성공적으로 수행된 트랜잭션은 영원히 반영되어야 한다.
      
  

### 트랜잭션 격리 수준
* Locking
  트랜잭션이 DB를 다루는 동안 다른 트랜잭션이 관여하지 못하게 하는 것
  무조건 적인 Locking은 동시에 수행되는 수많은 트랜잭션들을 순서대로 처리하는 방식으로 구현되면 DB의 성능은 떨어진다.
  응답성을 높이기 위해 Locking 범위를 줄인다면 잘못된 값이 처리될 여지가 있음
  그렇기 때문에 Isolation Level 이 필요

* Isolation Level의 종류 
  * Read UnCommitted
    - Select 문장이 수행되는 동안 해당 데이터에 Shared Lock이 걸리지 않는 Level
    - 트랜잭션에 처리중 혹은 아직 커밋되지 않은 데이터를 다른 트랜잭션이 읽는 것을 허용한다.
    - 즉 어떤 사용자가 A라는 데이터를 B로 변경하는 동안 다른 사용자는 아직 commit 되지 않은 트랜잭션이지만 데이터 B를 읽을수 있다 이를 Dirty Read라고 한다.
    - 데이터 베이스의 일관성을 유지할 수 없다. 
    
  * Read Committed
    - Select가 수행되는 동안 해당 데이터에 Shared Lock이 걸리는 레벨
    - 트랜잭션이 수행되는 동안 다른 트랜잭션이 접근할 수 없어 대기하게 된다.
    - commit이 이루어진 트랜잭션만 조회 가능
    - 어떤 사용자가 A라는 데이터를 B라는 데이터를 변경하는 동안 다른 사용자는 해당 데이터에 접근할 수 없다. Non-Repeatable-REad
    - SQL SERVER가 Default로 사용
  
  * Repeatable Read
    - 트랜잭션이 완료될 때 까지 SELECT 문장이 사용하는 모든 데이터에 Shared Lock이 걸리는 Level
    - 트랜잭션이 범위 내에서 조회한 데이터의 내용이 항상 동일함이 보장됨
    - 다른 사용자는 그 영역에 해당되는 데이터에 대한 수정이 불가능하다. (Insert는 가능 ) 
    - Phantom Read 발생
  
  * Serializable
    - 트랜잭션이 완료될 때 까지 SELECT 문장이 사용하는 모든 데이터에 Shared Lock이걸림 (Insert도 불가)
    - 완벽한 읽기 일관성 모드를 제공
    - Index를 설정할 경우 약간 다르게 동작
  
  
   Isonlaction Level을 조정하는 것은 동시성은 증가되나 데이터 무결성에 문제가 발생할 있고 Isolation Level을 높이면 데이터 무결성을 유지하는데 반해 동시성이 떨어진다.
    
### Index란
  데이터베이스에서 조회 및 검색을 더 빠르게 할 수 있는 방법으로 이에 쓰이는 자료구조 자체를 의미
  
  사용이유는 select문을 원하는 조건으로 검색할 때 저장된 데이터의 양이 많다면 검색을 위한 순회에 많은 자원과 시간이 소모 
  
  자주 조회되는 Column에 대해 Index Table을 따로 만들어 Select문이 들어왔을 때 index 테이블에 있는 값들로 결과 값들을 조회해 온다. 
  
  select 뿐만 아니라 update나 delete의 성능도 함게 향상되는데 그 이유는 결국 select와 연관되어 있기 때문이다. 
  
  join이나 where order by 등을 통해 자주 검색 하는 테이블이나 데이터의 중복도가 낮은 컬럼에 사용할 경우 성능 향상에 많은 기대를 얻을 수 있다. 
  
  단점으로는 index를 관리하기 위해 DB의 약 10%정도의 저장공간이 필요하고 insert , delete , update가 빈번한 테이블에 사용하게 된다면 인덱스의 크기가 커져 성능이 오히려 저하되는
  상황이 발생할 수 있다. 

### Inmemory DB가 필요한 이유

* Inmemory - DB 란
  - disk에 데이터를 저장하는 것이 아닌 memory에 데이터를 저장하는 방식을 사용하는 DB
  - 메모리 - disk간 병목 상황이 없기 때문에 disk-based db보다 속도가 훨씬 빠름
  * 장점
   - 성능이 매우 빠르다.
   - 테스트 용도로 많이 사용
  * 단점
   - 영속성을 보장하지 않음 (DB가 꺼지거나 문제가 생겨 다운될 경우 데이터가 모두 증발)
   - 메모리에 데이터를 저장하기 때문에 저장 공간이 한정되어 있음
      그렇기 때문에 어느 임계점에 도달하면 기존 데이터를 지우던가 새로운 데이터를 입력하지 못한다.
  - Inmemory DB와 NoSQL은 동의어가 아님
  - 대표적인 Inmemory DB로는 H2 DB가 있고 기존 mysql oracle의 경우도 inmemory 모드가 있다.


### ORM이란

객체 관계 매핑으로 객체와 관계형 데이터베이스의 데이터를 자동으로 매핑(연결)해주는 것
 - 객체 지향 프로그래밍은 클래스를 사용하고 , 관계형 데이터베이스는 테이블을 사용한다. 
 - 객체 모델과 관계형 모델 간에 불일치가 존재 한다.
 - ORM을 통해 객체 간의 관계를 바탕으로 SQL을 자동으로 생성하여 불일치 해결
 
 * 장점
  - 객체 지향적인 코드로 비즈니스 로직에 더 집중할 수 있게 해줌 SQL Query가 아니라 직관적인 코드(메서드)로 데이터를 조작할 수 있다. 
  - 재사용 및 유지보수의 편리성이 증가
  - DBMS에 대한 종속성이 줄어든다
   - 객체 간의 관계를 바탕으로 SQL을 자동으로 생성하기 때문에 RDBMS의 데이터 구조와 JAVA의 객체지향 모델 사이의 간격을 좁힐 수있다.
 * 단점
  - 완벽한 ORM으로만 서비스를 구현하기는 힘들다.
   - 사용하기에는 편리하지만 설계는 매우 신중
   - 프로젝트의 복잡성이 켜질경우 난이도 또한 증가
   - 구현이 잘못된다면 속도 저하 및 일관성이 무너진다.
  - 프로시저가 많은 시스템에선 ORM의 객체 지향적인 장저믈 활용하기 어렵다. 
  - 상속의 개념이 없다.

### Join

