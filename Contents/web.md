# 4. WEB
**:book: Contents**
* [HTTP와 HTTPS](#http와-https)
* [Cookie와 Session](#cookie와-session)
* [HTTP Method](#http-method)
* [브라우저에 URL을 입력했을 때 나타나는 과정](#브라우저에-url을-입력했을-때-나타나는-과정)
* [WEB-Server와 WAS차이](#ws-was)
* [REST 란](#what-is-rest)
* [DNS 란](#dns)

---

### HTTP와 HTTPS

**HTTP**

인터넷에서 데이터를 주고 받을 수 있는 프로토콜 즉 인터넷에서 데이터를 주고 받을 때 사용하는 규약

1.비연결성  

비연결성의 특징으로 인해 연결을 유지하기 위한 리소스를 줄여 더많은 연결을 할 수 있는 장점이 있다.
단점은 서버는 클라이언트를 기억하고 있지 않아 동인한 클라이언트의 모든 요청에 대해 매번 새로운 연결을 시도/ 해제 과정을 거쳐야하기 때문에 오버헤드가 발생한다는 단점이 있다. 

* KeepAlive
 - 비연결성의 해결책인 오버헤드를 줄이기위해 사용하는 HTTP의 속성
 - 지정된 시간동안 서버와 클라이언트 사이에서 패킷 교환이 없을 경우 상대방의 연결 여부를 알기위해 패킷을 보내는 것 패킷에 대해 반응이 없으면 접속을 끊게 되는 것
 - 주기적으로 클라이언트의 상태를 체크한다는 것으로 미루어 보아 Keep Alive 역시 해결책은 아니지만 서버가 바쁜상황에서 프로세스 수가 기하급수 적으로 늘어날 수 있어 메모리를 많이 사용하기 때문에 주의해야 한다. 

2. 무상태성
  비연결성으로 인해 서버는 클라이언트를 식별할 수가 없는 것 이로 인해 매번 새로운 인증을 해야하는 번거로움
  
  해결 방법으로 [쿠키와 세션](#cookie와-session)이 있음 
  
* HTTP 요청
 - Request Line , Request Header , Request Body로 구성되어있음
 - Reqeust Line에는 요청 URI와 HTTP프로토콜 버전 , HTTP Method 등이 간단하게 요약
 - Request Header에는 Http Method, Request Time Encoding , host address ip client port 등의 정보가 들어있다.
 - Request Body는 추가 컨텐츠를 서버로 보낼 수 있는 HTTP 요청의 일부이며 JSON 또는 XML의 파일의 유형이 많이 쓰인다. 없을 수도있음

* HTTP Response
 - Response Line, Header ,Body로 구성되어있다. 
 - 첫줄은 버전과 상태코드 , 상태 메시지로 구성되어 있다.
 - 헤더에는 응답에 대한 정보를 담고 있다.
 - Body에는 요청한 데이터를 바디에 담아져있음

* HTTP Response Code
100 요청을 받았으며 프로세스를 계속한다는 것을 의미
200~ 요청이 성공됨
300~ 요청 완료를 위해 추가작업인 redirection수행
400~ 클라이언트의 오류가 발생 요청 문법이 잘못되었거나 요청을 처리 할수 없는 경우
 - 400 BAD REQUEST 서버가 요청의 구문을 인식하지 못함
 - 401 UnAuthorize 서버는 로그인이 필요한 페이지에 대해 인증 안되어 반환
 - 403 Forbidden 서버가 요청 거부 사용자가 리소스에 대한 권할을 가지고 있지않음
 - 404 Not Found 요청한 페이지를 찾을 수 없음
 - 405 Not Allowed Method 요청에 대한 메서드가 잘못됨
500~ 서버가 명백히 유효한 요청에 대해 충족을 실패 즉 서버측 에러
 - 500 Internal Server Error :  서버에 오류가 발생하여 요청 수행 할수 없다.
 - 501 : 서버에 요청을 수행할 수 있는 기능이 없음
 - 502 Bad Gateway : 서버가 게이트웨이나 프록시 역할을 하고 있거나 또는 업스트림 서버에서 잘못된 응답을 받음


**HTTPS**
HTTP 프로토콜에 Secure Socket이 추가된 것 HTTPS를 사용하면 서버와 클라이언트 사이의 모든 통신 내용이 암호화 된다
SSL이나 TLS 프로토콜을 통해 세션 데이터를 암호화하고 SSL 프로토콜 위에서 HTTPS 프로토콜이 동작한다. 

암호화 방식은 공개키 암호화 방식과 느리다는 단점을 보완한 대칭키 암호화 방색을 사용한다. 공개키 방식으로 대칭키를 전달하고 서로 공유된 대칭키를 가지고 통신한다.

* 공개키 방식
 - A키로 암호화를 하면 B키로 복호화 할 수 있따.
 - B키로 암호화 하면 A 키로 복호화 가능
 - 둘중 하나를 비공개 키 혹은 개인키라 부르며 이는 자신만 가지고 있고 공개되지 않는다.
 - 나머지 하나를 공개키라고 부르며 타인에게 제공한다. 공개키는 유출이 되어도 비공개키를 모르면 복호화 할 수 없기 때문에 안전하다. 

* 대칭키 방식
 - 동일한 키로 암호화 복호화가 가능하다.
 - 대칭키는 매번 랜덤으로 생성되어 누출되어도 다음에 사용할 때는 다른키가 사용되기 때문에 안전하다. 
 - 공개키보다 빠르게 통신할 수 있다. 

SSL 방식을 적용하려면 인증서를 발급받아 서버에 적용시켜야 한다. 인증서는 사용자가 접속한 서버가 우리가 의도한 서버가 맞는지를 보장하는 역할을 한다. 

### Cookie와 Session

**Cookie**
사이트가 사용하고 있는 서버에서 사용자의 컴퓨터에 저장하는 작은 기록 정보 파일
HTTP에서 클라이언트의 상태 정보를 클라이언트의 PC에 저장하였다가 필요시 정보를 참조하거나 재사용할 수 있는 파일 
 * 이름 , 값 , 만료일 , 경로 정보로 구성됨
 * 클라이언트에 총 300개의 쿠키 저장 가능
 * 하나의 도메인당 20개의 쿠키를 가질 수 있음
 * 하나의 쿠키는 4KB 까지 저장 가능
 
 **동작순서**
  1. 클라이언트가 페이지를 요청
  2. 웹 서버는 쿠키 생성
  3. 생성한 쿠키에 정보를 담아 HTTP Response에 클라이언트에게 같이 담아서 전송
  4. 넘겨 받은 쿠키는 클라이언트가 가지고 있다가(Local 저장) 서버에 요청 할 때 요청과 함께 쿠키를 전송
  5. 동일 사이트 재방문 시 클라이언트의 PC에 해당 쿠키가 있는 경우 요청 페이지와 함께 쿠키를 전송
  
**Session**
일정 시간동안 같은 사용자로 부터 들어오는 request를 하나의 상태로 보고 그상태를 일정ㅎ아게 유지시키는 것
웹 브라우저를 통해 웹 서버에 접속한 시점으로부터 웹 브라우저에 종료하여 연결을 끝내는 시점을 말한다.
 
 * 웹 서버에 웹 컨테이너의 상태를 유지하기 위한 정보를 저장
 * 웹 서버의 저장되는 쿠키
 * 브라우저를 닫거나 서버에서 세션을 삭제했을 때만 삭제가 되므로 쿠키보다 비교적 보안이 좋다 -> 문제가 발생하면 세션을 삭제해버리면 끝
 * 저장 데이터에 제한이 없다 (서버가 무한하다면)
 * 각 클라이언트 고유 session id 부여하여 각 session id로 클라이언트를 구분하여 각 클라이언트의 요구에 맞는 서비스 제공

 **동작 순서**
  1. 클라이언트가 페이지를 요청
  2. 클라이언트의 request-header 필드인 쿠키를 확인하여 클라이언트가 해당 session-id를 보냈는지 확인
  3. session-id가 존재하지 않는다면 session-id를 생성하여 쿠키를 사용해 서버에 저장
  4. 클라이언트는 재접속 시 이 쿠키를 이용하여 session-id 값을 서버에 전달


쿠키는 로컬에 세션은 서버에 저장된다. 속도는 쿠키가 좀더 빠르며 안정성은 세션이 우세

### HTTP Method
HTTP Method는 클라이언트가 웹 서버에게 사용자 요청의 목적이나 종류를 알리는 수단이다.

**1.GET**
 * GET 메소드는 데이터를 읽거나 검색 할 때 사용되는 메서드
 * 요청이 성공적으로 이루어진다면 XML이나 JSOPN과 함께 200 OK 응답 코드를 리턴 
 * HTTP 명세에 의하면 GET 요청은 오로지 데이터를 읽을 때만 사용되고 수정할 때는 사용되지 않는다.
 * GET 요청은 같은 요청을 여러번 하여도 변함없이 항상 같은 응답을 받을 수 있다.
 * 데이터를 변경하는 연산에 사용하면 안된다.
 
 데이터를 조회하는 것이기 때문에 요청시에 Body값과 Content-Type이 비워져 있으며 조회할 때 데이터에 대한 정보는 URL을 통해 파라미터를 보낸다.
 성공한다면 Body값에 데이터 값이 저장되어 응답된다. 
 GET method는 캐싱이 가능하여 같은 데이터를 한번 더 조회할 경우 저장한 값을 사용하여 조회 속도가 빨라진다.
**2.POST**
 * 새로운 리소스를 생성할 때 사용
 * 기본적으로 creation 201 HTTP응답을 받는다.
 * 같은 요청을 반복한다 하더라도 항상 같은 결과물을 기대할 수 없다. 
 데이터를 생성하는 것이기 때문에 요청시에 Body값과 Content-Type을 명시하여 작성해야한다. URL을 통해 전송하지 않고 Body를 통해 전송한다. 
 데이터 조회에 성공한다면 Body값에 저장한 데이터 값을 저장하여 성공 응답을 보냄
**3.PUT**
 * 리소스를 / 생성 업데이트 하기위해 사용되는 메서드
 * 동일한 put요청에 대해 항상 동일한 결과가 생성
 * 데이터를 수정하기 때문에 요청시에 Body값과 Content-type값을 작성해야 한다.
 * 
**4.PATCH**
 * PUT 메서드와 같이 리소스를 업데이트 할때 사용
 * PUT은 지정한 데이터를 전부 수정하는 Method이지만 PATCH메서드는 일부분만 변경하기 때문에 항상 동일한 결과를 기대할 수 없음


**5.DELETE**
 * 지정된 리소스를 삭제


**6.HEAD**
 * 상태줄과 헤더만 반환


**7.OPTIONS**
 * 통신 가능 옵션을 설명


**8.CONNECT**
 * 자웡으로 식별되는 서버에 대한 터널


**9.TRACE**
 * 대상 리소스에 대한 경로를 따라 메시지 루프백 테스트 수행


### 브라우저에 url을 입력했을 때 나타나는 과정

1. 브라우저의 URL 파싱
 - URL을 입력 받은 브라우저는 URL의 구조를 해석하여 어떤 프로토콜로 어떤 도메인으로 어떤 보트로 보낼지 해석

2. HSTS(HTTP Strict Transport Security) 
 -HTTP를 허용하지 않고 HTTPS를 사용하는 연결만 허용하는 기능 HTTP로 요청이 왔다면 응답 헤더에 Strict Transport Security 라는 필드를 포함하여 응답 확인한 브라우저는 해당 서버에 요청할 때 HTTPS만을 통해 통신한다. 자신의 HSTS캐시에 해당 URL을 저장

3. URL을 IP 주소로 변환
 - 인터넷 상에서 컴퓨터가 읽을 수 있는 ip주소로 변환해야 서로 통신이 가능 자신의 로컬 hosts 파일과 브라우저 캐시에 해당 url 이 존재하는지 확인 -> 도메인 주소를 ip주소로 변환해주는 DNS 서버에 요청하여 URL을 ip로 변환
 
4. 라우터를 통해 해당 서버의 게이트웨이까지 이동

5. ARP를 통해 IP주소를 MAC Address로 변환

6. 대상 서버와 TCP 소켓 연결

8. HTTP(HTTPS) 프로토콜로 요청 및 응답


10. 브라우저에서 응답을 해석


### WS WAS

**WS**

**WAS**


### What is REST

### DNS
 사람이 읽을 수 있는 도메인 이름 Ex) www.naver.com 같은 것을 DNS
