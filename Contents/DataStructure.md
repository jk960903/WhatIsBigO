# 1. Data Structure
**:book: Contents**
* [Array](#array)
* [List](#list)
* [Stack](#stack)
* [Queue](#queue)
* [Set](#set)
* [Map](#map)
* [Tree](#tree)
* [Graph](#graph)
* [Heap](#heap)

---

### Array

같은 타입의 변수들이 연속적인 형태로 구성된 구조 각 원소에 붙은 번호를 index라고 하고 index를 통해 접근이 가능하다.
임의의 index로 접근하는 시간 복잡도는 O(1)이다.
메모리 구조가 연속되는 것을 요구하기 때문에 배열의 크기를 늘릴때는 배열을 복사해야하는 문제점이 있다.
데이터를 삽입 / 삭제하는 부분에서 연속된 상태를 유지해야하기 때문에 O(N)을 가진다

### List

**ArrayList**
<Java 기준>
일반 배열과 동일하게 연속된 메모리 공간을 사용한다. 
배열과 다른 부분은 배열은 크기가 고정적인 반면 ArrayList는 크기가 가변적으로 변한다. 
배열과 마찬가지로 index부분의 삽입 , 삭제를 할때는 O(N)이 소모가 되며 임의의 index 접근에는 O(1)이 소모된다.

**LinkedList**
데이터와 다음 순서의 위치가 저장되어있는 링크를 통해 이루어진 자료구조 연속된 메모리에 저장되지 않는다.
해당 값을 탐색하기 위해 링크를 타고 들어가야 하기 때문에 O(n)이 소요된다.
head와 tail값을 가지기 때문에 앞과 끝부분에 삽입 삭제에 O(1)의 소요된다.


### Stack

선입 후출의 자료구조 제일 처음 들어온 데이터가 제일 늦게 나가는 데이터 형식을 취하고 있다.
구현에는 배열을 통해 구현하는 것이 좋다
리스트로 스택을 구현하게 될 경우 tail의 위치를 기억하고 있다면 괜찮지만 tail의 위치가 저장되어 있지 않다면 리스트의 size 만큼 탐색이 이루어지기 때문에 array로 구현하는것이 좋다.

### Queue
선입 선출의 자료구조로 처음 들어온 데이터가 먼저 나가는 자료구조
구현에는 배열보다 리스트로 하는 것이 좋다.
리스트가 더 좋은이유는 Queue는 제일 처음 부분을 삭제하기 때문에 배열로 구현할 경우 모든 데이터를 한칸씩 앞으로 당겨야하기 때문에 O(n)이 소모된다.

### Set
데이터를 비순차적으로 저장할 수 있는 자료구조
중복을 허용하지 않아 같은 값을 삽입하게 되면 마지막에 삽입한 값 하나만 저장된다. 

* Hash Set
 - 해시 테이블을 사용해서 해시값을 기반으로 데이터를 저장하기 때문에 특정값을 포함하는지 확인하는 작업이 매우 빠르다. 탐색에 O(1) 삽입에 O(1)이 나옴


* Tree Set
 - 자바에서 Set 인터페이스를 구현한 컬렉션 클래스 이진 탐색 트리 형태로 Set을 구현
 - 정렬된 상태로 데이터가 저장되기 때문에 저장 순서를 유지하지 않음
 - 저장하는데 이진탐색 트리를 이용하기 때문에 저장 및 삭제의 비교연산이 필요하여 연산과정이 Hash Table을 이용한 것보다 느리다 Insert , Delete O(logn)
 - 반면 특정 값을 탐색하는데에도 O(Logn)이지만 특정 범위의 수를 걸러내는데 좋은 성능을 보인다.

* Linked Hash Set
  - HashSet과 비슷하지만 입력된 순서대로 데이터를 관리한다는 장점이 있는 Set


### Map
key - value 쌍우로 이루어진 데이터 집합체, 입력 순서는 유지되지 않으며 키는 중복을 허용하지 않고 값의 중복은 허용한다.

* HashMap
 - HashTable을 이용해 구현한 Map
 - 중복을 허용하지않고 순서 보장 X 
 - null 값 허용
* Tree Map
  - 이진탐색트리의 형태로 키와 값의 쌍으로 이루어진 데이터를 저장
  - 정렬된 순서로 키 값 쌍을 저장하기 때문에 빠른 검색이 가능하다
  - 저장시 정렬이 되기 때문에 저장 시간이 O(logn) 소요
* Linked hashMap
- 기본적으로 HashMap을 상속받아 HashMap과 매우 흡사
- 입력한 순서대로 저장됨



### Tree

### Graph

### Heap
