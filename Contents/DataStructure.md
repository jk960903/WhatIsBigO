# 1. Data Structure
**:book: Contents**
* [Array](#array)
* [List](#list)
* [Stack](#stack)
* [Queue](#queue)
* [Set](#set)
* [Map](#map)
* [Tree](#tree)
* [Graph](#graph)
* [Heap](#heap)

---

### Array

같은 타입의 변수들이 연속적인 형태로 구성된 구조 각 원소에 붙은 번호를 index라고 하고 index를 통해 접근이 가능하다.
임의의 index로 접근하는 시간 복잡도는 O(1)이다.
메모리 구조가 연속되는 것을 요구하기 때문에 배열의 크기를 늘릴때는 배열을 복사해야하는 문제점이 있다.
데이터를 삽입 / 삭제하는 부분에서 연속된 상태를 유지해야하기 때문에 O(N)을 가진다

### List

**ArrayList**
<Java 기준>
일반 배열과 동일하게 연속된 메모리 공간을 사용한다. 
배열과 다른 부분은 배열은 크기가 고정적인 반면 ArrayList는 크기가 가변적으로 변한다. 
배열과 마찬가지로 index부분의 삽입 , 삭제를 할때는 O(N)이 소모가 되며 임의의 index 접근에는 O(1)이 소모된다.

**LinkedList**
데이터와 다음 순서의 위치가 저장되어있는 링크를 통해 이루어진 자료구조 연속된 메모리에 저장되지 않는다.
해당 값을 탐색하기 위해 링크를 타고 들어가야 하기 때문에 O(n)이 소요된다.
head와 tail값을 가지기 때문에 앞과 끝부분에 삽입 삭제에 O(1)의 소요된다.


### Stack

선입 후출의 자료구조 제일 처음 들어온 데이터가 제일 늦게 나가는 데이터 형식을 취하고 있다.
구현에는 배열을 통해 구현하는 것이 좋다
리스트로 스택을 구현하게 될 경우 tail의 위치를 기억하고 있다면 괜찮지만 tail의 위치가 저장되어 있지 않다면 리스트의 size 만큼 탐색이 이루어지기 때문에 array로 구현하는것이 좋다.

### Queue
선입 선출의 자료구조로 처음 들어온 데이터가 먼저 나가는 자료구조
구현에는 배열보다 리스트로 하는 것이 좋다.
리스트가 더 좋은이유는 Queue는 제일 처음 부분을 삭제하기 때문에 배열로 구현할 경우 모든 데이터를 한칸씩 앞으로 당겨야하기 때문에 O(n)이 소모된다.

### Set


### Map

### Tree

### Graph

### Heap
